[notes]
### 2
 実際今から話していく中で、わからなかった点などもあります。最後にも話そうと思うんですが、また色々知識をつけたら再トライしたいなと思っています。
### 4
 
### 5
 
### 6
 
### 7
 configuration analysis toolってのはある。入力として、givenはnetwork config, correctness specification, possivle environment specificationを与えることで、そのenvの元で、configurationが常にcorrectness specificationを満たすかを吐き出す難しいのはscallability(ネットワーク規模の意味)である。（おそらく取り扱うものが多くなるから？）多くのツールはcorrectnessやexpressivenessを犠牲にした、これだと検証とは？みたいな気持ちになる。まぁ一分できるだけでも意義はあるが。minesweeperはSMT constraintを利用してネットワークをモデル化し、SMT Solverにより検証を実行することで、correctness, expressivenessの維持に成功した。ただし、minesweeperはscalability的には貧弱で、245台のデバイスネットワークのループチェックに4時間以上かかってしまった。結局、多くのprotocolをサポートし、かつscalableなconfiguration verification toolは作成できるのか？というのが焦点の論文になる
### 8
 
### 9
 
### 10
 
### 11
 また話の流れを図的に把握するために、ここから話すtopicとの対応をつけたのが下図以降、話の流れを見失わないように適宜参照しながら話していきます
### 12
 改めて今回の論文についての筆者らのkey contributionとしては次の３つです1つ目は、新たなconfiguration verificationのパラダイムとして、packet equivalence computationとexplicit-state model checkingによるものを定義したよ。2つ目は、1つ目の延長ですが、各種最適化を行いましたという話。3つ目は、実際に検証したよという話で、OSPF, BGP, Static Routingをサポートしたプロトタイプを実装し、実際に実用規模のスケールで検証可能であることと、最先端のverificationと比較して4桁以上差をつけたという話。
### 13
 
### 14
 ここでPlanktonのdesign overviewを示しておきます。
### 15
 以降の話は概ねこんな感じの部分の話になっていきます。
### 16
 今からはこの部分の話をしていきます。
### 17
 
### 18
 そもそもどういうことをするかというと、与えられた設定に対して、例えばあるノードAからBに対するreachabilityを検証する場合は、Aが送信可能なpacket patterをすべて生成して、Bに到達するかみたいなことを確認するようなことをします。この場合、SWはある種の入力に対して、いくつかの出力を割り当てるような転送関数としてみることで、最終的にAが生成するheader spaceのサブセットがBに到達する、みたいなことを見つける形になります。これを各種nodeで全パターン確認する、みたいなことをすると流石にしんどいんですが、網羅性を担保するためにはそれらしいことをやるしか無いわけです
### 19
 いまそれらしいことをやる必要があるといったんですが、これが等価の議論につながる感じになります。すなわちpacket同士のequivalence(等価性)みたいなものをうまく定義することができれば、等価であるpacketは一つ試せばいいので計算量を削減することができます。そこで、packetのequivalenceはどうするの？という話になってくるのですが、これが今回導入するPacket Equivalence Classというもので、Tri-Tree ベースで考えていくものになります。今回どのようなpacketが等価であるか、というと同一configurationを利用するpacketは等価である、と定義します。これをPacket Equialence Classesとするようです。
### 20
 例えばOSPF上で、128.0.0.0というprefixのものと、192.0.0.0というprefixのものがアドバタイズされている例を考えてみる。この場合、図のようなトライ木を構築するそうです。トライ木のノードである各prefixにはそれぞれconfigが紐付けられてている、というイメージで構築していくようで、それぞれがPacket Equivalenceである、という形になります。なので、この例の場合はPrefixが0.0.0.0-127.255.255.255の範囲、128.0.0.0-191.255.255.255の範囲、192.0.0.0-255.255.255.255の範囲のpacketがそれぞれ等価、という感じです。考慮するIPアドレスが必要だろうと個人的に思うのですが、これはおそらく対象nodeのPacket header spaceのIPアドレスから考えるのかな、と思います。（それはそう？）\par （1ずつ伸びていくのか？ -> これはtriの実装の仕方によるきがしている。別に矢印に11111...みたいなものを対応付けるのもいいとは思う（挿入操作などでちょっとつけかえが発生するが））明確な言及がないのであくまで個人的な解釈。prototype作ったんならコード公開してくれ、という気持ちがある。（プロトコル実行前にどうやってこのPEC計算するの？）それな。基本的にはconfigurationがgivenなのでその内容を見てどのpacketの単位で分割するのか、というのは決まる。次に実際にプロトコルを実行する際には、対象のnodeのpacket header spaceを見て、どのPECを利用する形になるのか判定する形になると思っている。それぞれのPECごとに各nodeでは振る舞いが変わるはずなので、検証の単位がPECの粒度になる、と思う。（一回のprotocol実行で検証するのは一つのPECという感じ？）
### 21
 PEC単位で基本的な検証を行うんだが、ProtocolとしてBGP, OSPF？みたいなところは同時検証というわけではなく、それも網羅的に探索される。そのため、OSPFが前提であるようなiBGPみたいな環境では、OSPFでの検証結果を踏まえて、iBGPの検証をしないといけなかったりする。つまり、PEC間に依存関係ができてしまう。これをSCCと読んでいる。これについてはちゃんと考えなければいけないという話。(iBGP over OSPFのことはよくわかっていない。) 
### 22
 基本的な方針としてはPEC単位で、独立しているので並列化して計算してやればいいが、SCCに関してはそういうわけには行かないのでうまくスケジューリングする必要がある。そのためのスケジューラ(モデルチェックのプロセスについてのスケジューリングをしてくれるやつ)というのがありますよ、という話。あまり詳細がなくそれ以上の情報がいまいちつかめなかった。
### 23
 今からはこの部分の話をしていきます。
### 24
 
### 25
 
### 26
 
### 27
 import n n' はnode nがn'からpath情報を受信することを意味していて、export n' nはn'がnにpath情報を送信することを言っている、と思われる。
### 28
 ここでPlanktonのdesign overviewを示しておきます。
### 29
 
### 30
 
### 31
 
### 32
 
### 33
 
### 34
 
### 35
 inconsistent execution(矛盾するような)について削減する
### 36
 
### 37
 
### 38
 
### 39
 
### 40
 
### 41
 
### 42
 
### 43
 
### 44
 
### 45
 
### 46
 
### 47
 
### 48
 
### 49
 
### 50
 
### 51
 
### 52
 
### 53
 
### 54
 同じエッジスイッチに接続されている2台のサーバーが通信する場合、コアレベルを参照せずに、その特定のエッジスイッチを介して通信できる. 逆に、サーバーが別のエッジスイッチに接続されている場合、パケットはいずれかのコアスイッチに到達し、次にターゲットエッジスイッチに到達します。
### 55
 グラフの説明PlanktonはMinesweeperに比べ、どのネットワークサイズでも現実的な速度でスケールしていることがわかる（現実的なスケールの話というよりはスケーラビリティの話）メモリ利用量は並列度に比例して大きくなり、速度は反比例しており想定通りで、Minesweeperと比較すると16coreまで並列度を上げてもメモリ使用量は低いままで、速度を見ると,K=10だと例えば2000sなのが、0.4, 5sくらいになっている。
### 56
 minesweeperでは無限に時間がかかるので試していないとのこと2205のdeviceネットワークでは、planktonは1回の処理で170GB使用する
### 57
 Rocketfuelとか言うものがあるらしい（元論文らしきものは見つかった。ISP topologyを測定するという題名のもの）Topology生成とかやってくれるのかなと思っているが、詳細についてはちょっと確認できてません。\par なんか同じくらいになっているのは何だろね。。。
### 58
 \par 前ページのOSPFと単純に比較できる感じのものではない？うーん、ちょっとなんとも言えないな。。
### 59
 括弧内はデバイス数、ちょっと少ない？気もしないでもない。モデルとかではなくて実際のネットワークで確認した、という意味合いが強いのかな\par Way-Pointing : 想定したノードを通っているか、とかかな？Bounded Path Length : パス帳制限ポリシー\par 検証する中で割と色々わかった面があるみたいな話が書いてあった。（話さなくていい）1. 間接的なstatic routeやiBGPのような何らかの形の再帰的ルーティングが使用されていた。-> MinesweeperやPlanktonがこれらの設定をサポートすることの重要性を強調していると感じている2. PEC dependency graphには1つのPEC以上の強く接続されているコンポーネントは存在していなかった。-> 我々の期待と一致している3. 非決定性があるのは失敗したリンクの選択だけ-> 現実世界のネットワーク構成は大部分が決定的であるという直感を裏付けていた。
### 60
 結果はPlanktonのもののみ。Timeを見るとおよそ30sec程度で検証が完了している。\par Loop : ループが発生するかどうか。Path Consistency: Pathの一貫性（特にlink failureとかの時のリアクションとかが気になる気がする）MultiPath Consistency: 複数Pathがあるときに両方 (複数pathバージョンかな？) 
### 61
 
### 62
 
